

# --------------------------------------------------------------------------
# Try to find VTK and include its settings (otherwise complain)
# 
FIND_PACKAGE(VTK NO_MODULE REQUIRED PATHS ${VTK_DIR} NO_DEFAULT_PATH)
IF ( VTK_FOUND )
INCLUDE(${VTK_USE_FILE})
ELSE ( VTK_FOUND )
    MESSAGE( FATAL_ERROR "This application requires VTK. One of these components is missing. Please verify configuration")
ENDIF ( VTK_FOUND )

#
# Try to find ITK and include its settings (otherwise complain)
# 
FIND_PACKAGE (ITK REQUIRED PATHS ${ITK_DIR} NO_DEFAULT_PATH)
IF ( ITK_FOUND )
  INCLUDE( ${ITK_USE_FILE} )
ELSE ( ITK_FOUND )
    MESSAGE( FATAL_ERROR "This application requires ITK. One of these components is missing. Please verify configuration")
ENDIF( ITK_FOUND )


# --------------------------------------------------------------------------
# Use OpenIGTLink protocol
# 
OPTION(PLUS_USE_OpenIGTLink "Use the OpenIGTLink protocol" OFF)
SET(PLUS_OPENIGTLINK_VERSION)
IF(PLUS_USE_OpenIGTLink)
  FIND_PACKAGE(OpenIGTLink PATHS ${OpenIGTLink_DIR} NO_DEFAULT_PATH)
  IF (OpenIGTLink_USE_FILE)
    INCLUDE (${OpenIGTLink_USE_FILE})
  ELSE (OpenIGTLink_USE_FILE)
    MESSAGE( FATAL_ERROR "This application requires OpenIGTLink. One of these components is missing. Please verify configuration")
  ENDIF (OpenIGTLink_USE_FILE)
  SET(PLUS_OPENIGTLINK_VERSION "${OpenIGTLink_VERSION_MAJOR}.${OpenIGTLink_VERSION_MINOR}.${OpenIGTLink_VERSION_PATCH}" )
  SET(PLUS_OPENIGTLINK_VERSION_MAJOR "${OpenIGTLink_VERSION_MAJOR}")
  SET(PLUS_OPENIGTLINK_VERSION_MINOR "${OpenIGTLink_VERSION_MINOR}")
  SET(PLUS_OPENIGTLINK_VERSION_PATCH "${OpenIGTLink_VERSION_PATCH}")
ENDIF(PLUS_USE_OpenIGTLink)


# --------------------------------------------------------------------------
# Options
OPTION(BUILD_SHARED_LIBS "Build with shared libraries." ${VTK_BUILD_SHARED_LIBS} ${ITK_BUILD_SHARED_LIBS} )     
# OPTION (BUILD_SLICER_MODULE "Build project as Slicer module" OFF)

# --------------------------------------------------------------------------
# Use accurate or simple timer protocol
# 
# DevPartnerStudio performance profiler hangs if the accurate timer
# is used.If USE_SIMPLE_TIMER is defined then the accurate timer is
# bypassed. It should only be enabled for performance profiling.

OPTION(PLUS_USE_SIMPLE_TIMER "Use simple timer (not very accurate but more compatible with performance profilers)" OFF)
MARK_AS_ADVANCED(PLUS_USE_SIMPLE_TIMER)

OPTION(PLUS_USE_INTEL_MKL "Use the Intel MKL library (only for image processing)" OFF)

# --------------------------------------------------------------------------
# Configure output paths for libraries and executables.
#
IF(NOT DEFINED PLUS_EXECUTABLE_OUTPUT_PATH)
  SET(PLUS_EXECUTABLE_OUTPUT_PATH "${PlusLib_BINARY_DIR}/bin")
ENDIF()
SET(LIBRARY_OUTPUT_PATH  ${PLUS_EXECUTABLE_OUTPUT_PATH} CACHE PATH "Single output directory for building all libraries." FORCE)
SET(EXECUTABLE_OUTPUT_PATH ${PLUS_EXECUTABLE_OUTPUT_PATH} CACHE PATH "Single output directory for building all executables." FORCE)
SET(INCLUDES_OUTPUT_PATH ${PLUS_EXECUTABLE_OUTPUT_PATH} CACHE PATH "Single output directory for all include files" FORCE)
MARK_AS_ADVANCED(LIBRARY_OUTPUT_PATH EXECUTABLE_OUTPUT_PATH INCLUDES_OUTPUT_PATH)

IF(${CMAKE_GENERATOR} MATCHES "Visual Studio")
  SET(TEST_OUTPUT_PATH "${PLUS_EXECUTABLE_OUTPUT_PATH}/Release/Output")
ELSE()
  SET(TEST_OUTPUT_PATH "${PLUS_EXECUTABLE_OUTPUT_PATH}/Output")
ENDIF()

# --------------------------------------------------------------------------
# Sikuli binary directory path.
# 
SET(SIKULI_BIN_DIR ${PLUSLIB_TOOLS_DIR}/Sikuli/ CACHE PATH "Path to the Sikuli binary directory." FORCE)

# --------------------------------------------------------------------------
# The project library directories.
SET(PLUSLIB_LIBRARY_DIRS ${LIBRARY_OUTPUT_PATH} CACHE INTERNAL "Path to the Plus library directory" FORCE)

# Library directories should be added automatically by the build system, however GrabbieLib
# is not found by default (as it does not have a proper USE file), therefore we add
# the library output directory to the library search path
LINK_DIRECTORIES(${LIBRARY_OUTPUT_PATH})

# --------------------------------------------------------------------------
# Configure include file
# 
CONFIGURE_FILE(
  ${CMAKE_CURRENT_SOURCE_DIR}/PlusConfigure.h.in 
  ${CMAKE_CURRENT_BINARY_DIR}/PlusConfigure.h
  )
CONFIGURE_FILE(
  ${CMAKE_CURRENT_SOURCE_DIR}/PlusRevision.h.in 
  ${CMAKE_CURRENT_BINARY_DIR}/PlusRevision.h
  )  

# --------------------------------------------------------------------------
# Command-line application documentation
#

# Create directory for the command-line application help files (they are generated by after build by running
# each command-line tool with the --help parameter)
IF(BUILD_DOCUMENTATION)
  FILE(MAKE_DIRECTORY ${EXECUTABLE_OUTPUT_PATH}/Doc/Help)
ENDIF(BUILD_DOCUMENTATION)

# This macro generates a command-line application help file
MACRO(GENERATE_HELP_DOC TARGET_NAME)
  IF(BUILD_DOCUMENTATION)
    ADD_CUSTOM_COMMAND(
      TARGET ${TARGET_NAME}
      POST_BUILD
      COMMAND $<TARGET_FILE:${TARGET_NAME}> --help > ${TARGET_NAME}Help.txt
      WORKING_DIRECTORY ${EXECUTABLE_OUTPUT_PATH}/Doc/Help
      )
  ENDIF(BUILD_DOCUMENTATION)
ENDMACRO(GENERATE_HELP_DOC) 

# --------------------------------------------------------------------------
# Library export directive file generation
#

# This macro generates a ...Export.h file that specifies platform-specific DLL export directives,
# for example on Windows: __declspec( dllexport )
MACRO(GENERATE_EXPORT_DIRECTIVE_FILE LIBRARY_NAME)
  SET (MY_LIBNAME ${LIBRARY_NAME})
  SET (MY_EXPORT_HEADER_PREFIX ${MY_LIBNAME})
  SET (MY_LIBRARY_EXPORT_DIRECTIVE "${MY_LIBNAME}Export")
  CONFIGURE_FILE(
    ${PlusLib_SOURCE_DIR}/src/PlusExport.h.in
    ${CMAKE_CURRENT_BINARY_DIR}/${MY_EXPORT_HEADER_PREFIX}Export.h
    )
ENDMACRO(GENERATE_EXPORT_DIRECTIVE_FILE) 

# --------------------------------------------------------------------------
# Initialize variables that will be filled by makefiles in subdirectories
#

# PLUSLIB_DEPENDENCIES contain all the exported targets that will be
# available to applications that use PlusLib
SET(PLUSLIB_DEPENDENCIES "" CACHE INTERNAL "" )

# PLUSLIB_INCLUDE_DIRS contain all the include directories that will be
# available to applications that use PlusLib
SET(PLUSLIB_INCLUDE_DIRS "" CACHE INTERNAL "" )

# --------------------------------------------------------------------------
# Current directory

SET (BASIC_INCLUDE_DIRS 	
  "${CMAKE_CURRENT_SOURCE_DIR}"
  "${CMAKE_CURRENT_BINARY_DIR}"
  )
INCLUDE_DIRECTORIES( ${BASIC_INCLUDE_DIRS} )
SET(PLUSLIB_INCLUDE_DIRS ${PLUSLIB_INCLUDE_DIRS} ${BASIC_INCLUDE_DIRS} CACHE INTERNAL "" )

# --------------------------------------------------------------------------
# Subdirectories

# Variables sent back from subdirectories (through CACHE):
# ..._INCLUDE_DIRS
# vcProj_...
# PLUSLIB_DEPENDENCIES

ADD_SUBDIRECTORY(Utilities)
INCLUDE_DIRECTORIES( ${Utilities_INCLUDE_DIRS} )
SET(PLUSLIB_INCLUDE_DIRS ${PLUSLIB_INCLUDE_DIRS} ${Utilities_INCLUDE_DIRS} CACHE INTERNAL "" )

ADD_SUBDIRECTORY(PlusCommon)
INCLUDE_DIRECTORIES( ${PlusCommon_INCLUDE_DIRS} )
SET(PLUSLIB_INCLUDE_DIRS ${PLUSLIB_INCLUDE_DIRS} ${PlusCommon_INCLUDE_DIRS} CACHE INTERNAL "" )

IF(PLUS_USE_OpenIGTLink)
  ADD_SUBDIRECTORY(PlusOpenIGTLink)
  INCLUDE_DIRECTORIES( ${PlusOpenIGTLink_INCLUDE_DIRS} )
  SET(PLUSLIB_INCLUDE_DIRS ${PLUSLIB_INCLUDE_DIRS} ${PlusOpenIGTLink_INCLUDE_DIRS} CACHE INTERNAL "" )
ENDIF()

ADD_SUBDIRECTORY(ImageProcessingAlgo)
INCLUDE_DIRECTORIES( ${ImageProcessingAlgo_INCLUDE_DIRS} )
SET(PLUSLIB_INCLUDE_DIRS ${PLUSLIB_INCLUDE_DIRS} ${ImageProcessingAlgo_INCLUDE_DIRS} CACHE INTERNAL "" )

ADD_SUBDIRECTORY(UsSimulatorAlgo)
INCLUDE_DIRECTORIES( ${UsSimulatorAlgo_INCLUDE_DIRS} )
SET(PLUSLIB_INCLUDE_DIRS ${PLUSLIB_INCLUDE_DIRS} ${UsSimulatorAlgo_INCLUDE_DIRS} CACHE INTERNAL "" )

ADD_SUBDIRECTORY(VolumeReconstruction)
INCLUDE_DIRECTORIES( ${VolumeReconstruction_INCLUDE_DIRS} )
SET(PLUSLIB_INCLUDE_DIRS ${PLUSLIB_INCLUDE_DIRS} ${VolumeReconstruction_INCLUDE_DIRS} CACHE INTERNAL "" )

# DataCollection
ADD_SUBDIRECTORY(DataCollection)
INCLUDE_DIRECTORIES( ${DataCollection_INCLUDE_DIRS} )
SET(PLUSLIB_INCLUDE_DIRS ${PLUSLIB_INCLUDE_DIRS} ${DataCollection_INCLUDE_DIRS} CACHE INTERNAL "" )

ADD_SUBDIRECTORY(CalibrationAlgo)
INCLUDE_DIRECTORIES( ${CalibrationAlgo_INCLUDE_DIRS} )
SET(PLUSLIB_INCLUDE_DIRS ${PLUSLIB_INCLUDE_DIRS} ${CalibrationAlgo_INCLUDE_DIRS} CACHE INTERNAL "" )

IF(PLUS_USE_OpenIGTLink)
  ADD_SUBDIRECTORY(PlusServer)
  INCLUDE_DIRECTORIES( ${PlusServer_INCLUDE_DIRS} )
  SET(PLUSLIB_INCLUDE_DIRS ${PLUSLIB_INCLUDE_DIRS} ${PlusServer_INCLUDE_DIRS} CACHE INTERNAL "" )
ENDIF()

ADD_SUBDIRECTORY(scripts)

FILE(GLOB headers 
  "${CMAKE_CURRENT_SOURCE_DIR}/*.h"
  )

# --------------------------------------------------------------------------
# Create Plus target list 

# Add all targets to the build-tree export set
export(TARGETS 
  ${PLUSLIB_DEPENDENCIES}
  FILE "${CMAKE_CURRENT_BINARY_DIR}/PlusLibLibraryDepends.cmake"
  )    
 
# Export the package for use from the build-tree
# (this registers the build-tree with a global CMake-registry)
export(PACKAGE PlusLib)

# Create a PlusConfig.cmake file for the use from the build tree
CONFIGURE_FILE(PlusLibConfig.cmake.in
  "${CMAKE_CURRENT_BINARY_DIR}/PlusLibConfig.cmake" @ONLY)
CONFIGURE_FILE(PlusLibConfigVersion.cmake.in
  "${CMAKE_CURRENT_BINARY_DIR}/PlusLibConfigVersion.cmake" @ONLY)

#-----------------------------------------------------------------------------
# Generate default application configuration files in the non-installed executable directories (Release and Debug too)
# 
SET( PLUSCONFIG_DEVICESET_CONFIG_DIR "${PLUSLIB_DATA_DIR}/ConfigFiles" )
SET( PLUSCONFIG_IMAGE_DIR "${PLUSLIB_DATA_DIR}/TestImages" )
SET( PLUSCONFIG_MODEL_DIR "${PLUSLIB_DATA_DIR}/CADModels" )
SET( PLUSCONFIG_SCRIPTS_DIR "${PLUSLIB_SCRIPTS_DIR}" )

IF ( ${CMAKE_GENERATOR} MATCHES "Visual Studio" )
  # PlusConfig.xml generation for Windows (separate directories for different build types)
  configure_file(
    ${CMAKE_CURRENT_SOURCE_DIR}/PlusConfig.xml.in
    ${PLUS_EXECUTABLE_OUTPUT_PATH}/Release/PlusConfig.xml
    )	    
  CONFIGURE_FILE(
    ${CMAKE_CURRENT_SOURCE_DIR}/PlusConfig.xml.in
    ${PLUS_EXECUTABLE_OUTPUT_PATH}/Debug/PlusConfig.xml
    )
ELSE()
  # PlusConfig.xml generation for other OS (only one build type is supported)
  CONFIGURE_FILE(
    ${CMAKE_CURRENT_SOURCE_DIR}/PlusConfig.xml.in
    ${PLUS_EXECUTABLE_OUTPUT_PATH}/PlusConfig.xml
    )
ENDIF()
  
#-----------------------------------------------------------------------------
# Documentation
#
OPTION(BUILD_DOCUMENTATION "Build the documentation (Doxygen)." OFF)
MARK_AS_ADVANCED(BUILD_DOCUMENTATION)
 
IF(BUILD_DOCUMENTATION)

  SET(PROGWIN64 "PROGRAMFILES")
  SET(PROGWIN32 "PROGRAMFILES(X86)")

  # Try to detect GraphViz path (CMake's Doxygen package finder only tries some obsolete paths on Windows)
  FIND_PROGRAM(DOXYGEN_DOT_EXECUTABLE
    NAMES dot
    PATHS
      "$ENV{${PROGWIN32}}/Graphviz2.38/bin"
      "$ENV{${PROGWIN64}}/Graphviz2.38/bin"
      "$ENV{${PROGWIN32}}/Graphviz2.34/bin"
      "$ENV{${PROGWIN64}}/Graphviz2.34/bin"
    DOC "Graphviz Dot tool for using Doxygen"
    NO_SYSTEM_ENVIRONMENT_PATH
  )

  IF(WIN32)
    SET(DOXYGEN_HHC_EXECUTABLE "${PLUSLIB_TOOLS_DIR}/HtmlHelp/hhc.exe" CACHE FILEPATH "Path to the Windows HTML Help Compiler tool." FORCE)
  ENDIF(WIN32)

ENDIF(BUILD_DOCUMENTATION)

ADD_SUBDIRECTORY(Documentation)

#-----------------------------------------------------------------------------
# Generate include file for projects that use this library 
# 
CONFIGURE_FILE(
  ${CMAKE_CURRENT_SOURCE_DIR}/UsePlusLib.cmake.in 
  ${CMAKE_CURRENT_BINARY_DIR}/UsePlusLib.cmake @ONLY)	
